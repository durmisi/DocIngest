using DocIngest.Core;
using DocIngest.Core.Middlewares;
using DocIngest.Core.Services;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

// Generated by Copilot

static (string inputPath, string outputPath, string tempPath) ConfigurePaths()
{
    var inputPath = Path.Combine(Directory.GetCurrentDirectory(), "input/invoices");
    var outputPath = Path.Combine(Directory.GetCurrentDirectory(), "output");
    var tempPath = Path.Combine(Directory.GetCurrentDirectory(), "temp");
    Directory.CreateDirectory(inputPath);
    Directory.CreateDirectory(outputPath);
    Directory.CreateDirectory(tempPath);
    return (inputPath, outputPath, tempPath);
}

static IServiceProvider ConfigureServices(string[] args, string outputPath)
{
    var apiKey = Environment.GetEnvironmentVariable("OPENAI_API_KEY");

    var config = new ConfigurationBuilder()
        .AddJsonFile("appsettings.json", optional: true)
        .AddEnvironmentVariables()
        .AddCommandLine(args)
        .Build();

    var services = new ServiceCollection();
    services.AddSingleton<IConfiguration>(config);
    services.AddLogging(logging => logging.AddConsole());
    services.AddSingleton<IOcrService, TesseractOcrService>();
    services.AddSingleton<IDocumentGenerator, DefaultDocumentGenerator>();
    services.AddSingleton<IDeliveryService>(sp => new FolderDeliveryService(outputPath, sp.GetRequiredService<ILogger<FolderDeliveryService>>()));
    // AI categorization commented out for now
    // if (!string.IsNullOrEmpty(apiKey))
    // {
    //     services.AddOpenAIChatClient(options => options.ApiKey = apiKey);
    // }

    return services.BuildServiceProvider();
}

static async Task RunPipeline(IServiceProvider serviceProvider, string inputPath, string tempPath)
{
    var loggerFactory = serviceProvider.GetRequiredService<ILoggerFactory>();
    var traversalLogger = loggerFactory.CreateLogger<DocumentTraversalMiddleware>();
    var processingLogger = loggerFactory.CreateLogger<DocumentProcessingMiddleware>();
    // var aiLogger = loggerFactory.CreateLogger<AiCategorizationMiddleware>();
    var deliveryLogger = loggerFactory.CreateLogger<DeliveryMiddleware>();

    var ocrService = serviceProvider.GetRequiredService<IOcrService>();
    var generator = serviceProvider.GetRequiredService<IDocumentGenerator>();
    var deliveryService = serviceProvider.GetRequiredService<IDeliveryService>();
    var config = serviceProvider.GetRequiredService<IConfiguration>();
    // var chatClient = serviceProvider.GetService<IChatClient>();

    var builder = new PipelineBuilder();
    builder.Use(new DocumentTraversalMiddleware(inputPath, traversalLogger));
    builder.Use(new DocumentProcessingMiddleware(ocrService, config, processingLogger, generator));
    // if (chatClient != null)
    // {
    //     builder.Use(new AiCategorizationMiddleware(chatClient, ocrService, aiLogger));
    // }
    builder.Use(new DateParsingMiddleware(loggerFactory.CreateLogger<DateParsingMiddleware>()));
    builder.Use(new DeliveryMiddleware(deliveryService, deliveryLogger));

    var pipeline = builder.Build();

    var context = new PipelineContext();
    // Define organization function for "month" logic
    Func<Document, string> organizationFunc = (doc) =>
    {
        var tag = doc.ProcessedFiles.FirstOrDefault()?.Tags.FirstOrDefault(t => Regex.IsMatch(t, @"\d{4}/\d{2}"));
        if (tag != null)
        {
            return tag; // e.g., "2023/01"
        }
        var dirInfo = new DirectoryInfo(doc.Path);
        return dirInfo.CreationTime.ToString("yyyy-MM");
    };
    context.Items["OrganizationPathFunc"] = organizationFunc;
    context.Items["OutputDirectory"] = tempPath;

    await pipeline(context);

    var docs = context.Items["Documents"] as List<Document>;
    Console.WriteLine($"Found {docs?.Count ?? 0} documents");
    if (docs != null)
    {
        foreach (var doc in docs)
        {
            Console.WriteLine($"Document: {doc.Name}, Files: {doc.Files.Count}, Processed: {doc.ProcessedFiles.Count}");
        }
    }

    Console.WriteLine("Processing complete.");
}

var (inputPath, outputPath, tempPath) = ConfigurePaths();
var serviceProvider = ConfigureServices(args, outputPath);
await RunPipeline(serviceProvider, inputPath, tempPath);